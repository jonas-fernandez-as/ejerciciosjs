<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Nuevos tipos de datos en JavaScript</title>
</head>
<body>
 <h1>Nuevos tipos de datos en JavaScript</h1>

 <script>


//******************************************************************









//SYMBOL








/*
  let id =Symbol("id")
  let id2=Symbol("id2")

  console.log(id === id2)
  console.log(id,id2)
  console.log(typeof id, typeof id2);

  const NOMBRE=Symbol();

  const persona={
   [NOMBRE]:"Jonás"
  }
 
  console.log(persona)

  persona.NOMBRE ="Jonas Fernandez"
  console.log(persona);
  console.log(persona.NOMBRE);
  console.log(persona[NOMBRE]);

  persona[SALUDAR]=function(){
   console.log("Hola")
  }

 console.log(persona);
 persona[SALUDAR]();

 for(let propiedad in persona){
  console.log(propiedad)
  console.log(persona[propiedad])
 }

 console.log(Object.getOwnPropertySymbols(persona))
 
 */
 
 //******************************************************************
 
 
 
 
 
 
 
 
 
 //SETS

 







/*Solo acepta valores unicos no repetidos*/
/*
const set=new Set([1,2,3,3,3,4,5,6,6,6,true,true,false,"HOLA","hola",{},{}])
console.log(set)
console.log(set.size);
const set2=new Set()

set2.add(1)
set2.add(2)
set2.add(2)
set2.add(3)
set2.add(true)
set2.add(false)
set2.add(true)
set2.add({})
set2.add([])

console.log("Recorriendo set")

for (item of set){
 console.log(item);
}

console.log("Recorriendo se2")

set2.forEach(item=>console.log())
let arr= Array.from(set)

console.log(arr[0])
console.log(arr[9])

set.delete("HOla")
 console.log(set.has("hola"))
 console.log(set.has(19))
 
 set2.clear()
 console.log(set2)
 */




//**************************************************************












//MAPS







/*
const mapa = new Map();


mapa.set("nombre","Jonás")
mapa.set("apellido","Fernandez")
mapa.set("edad",35)

console.log(mapa)
console.log(mapa.size)
console.log(mapa.has("correo"))
console.log(mapa.has("nombre"))
console.log(mapa.get("nombre"))
mapa.set("nombre","Jonas Fernandez")
console.log(mapa.get("nombre"))
mapa.delete("apellido")

mapa.set(19,"diecinueve")
mapa.set(false,"falso")
mapa.set({},{})
console.log(mapa)


for(let[key,value]of mapa){
 console.log(`Llave: ${key} - Valor: ${value}`)
}


const mapa2 = new Map([
 ["nombre","kEnAi"],
 ["edad",7],
 ["animal","perro"],
 [null,"nulo"]
])

console.log(mapa2)

const llavesMapa2= [...mapa2.keys()]
const valoresMapa2=[...mapa2.values()]

console.log(llavesMapa2)
console.log(valoresMapa2)
*/



//**************************************************************








//WEAK SETS Y WEAK MAPS

//const ws= new WeakSet([1,2,3,3,4,5,true,false,false,{},{},"hola","HOla"])
/*
const ws= new WeakSet();

let valor1={"valor1":1};
let valor2={"valor2":2};
let valor3={"valor3":3};

ws.add(valor1)
ws.add(valor2)

console.log(ws)

console.log(ws.has(valor3))
console.log(ws.has(valor2))

ws.delete(valor2)
console.log(ws)

ws.add(valor2)
ws.add(valor3)

console.log(ws)



setInterval(()=>console.log(ws),1000)

setTimeout(() => {
  valor1=null
  valor2=null
  valor3=null
console.log("weak set del timeout")
}, 5000);
*/
/*
NO SE DEBE ESTABLECER UN WEAK MAP O UN WEAK SET DE ESTA MANERA
const wm=new WeakMap([
  ["nombre","kenai"],
  ["edad",7],
  ["animal","perro"],
  [null,"nulo"]
])
*/
//NO SON ITERABLES
//SI PODEMOS SABER SI TIENE UNA REFERENCIA EN UNA POSICION
/*
const wm=new WeakMap();
let llave1={}
let llave2={}
let llave3={}

wm.set(llave1,1)
wm.set(llave2,2)

console.log(wm.has(llave1))
console.log(wm.has(llave3))

console.log(wm.get(llave1))
console.log(wm.get(llave2))
console.log(wm.get(llave3))

wm.delete(llave2)
console.log(wm)

wm.set(llave2,2)
wm.set(llave3,3)

console.log(wm)

//ESTO FUNCIONA EL CHROME,NO EN FIREFOX

setInterval(()=>console.log(wm),1000);

setTimeout(()=>{
  llave1=null
  llave2=null
  llave3=null
  console.log("coso")
},5000)

*/

//*******************************************************************++
















//ITERABLES & ITERATORS 



/*

const iterable =new Set[1,2,2,3,3,4,5,5];
//Accedemos al iterador del iterable
const iterador= iterable[Symbol.iterator]();

console.log(iterable)
console.log(iterador)
//console.log(iterador.next())
//console.log(iterador.next())
//console.log(iterador.next())
//console.log(iterador.next())
//console.log(iterador.next())

let next= iterator.next();

while(!next.done){
  console.log(next.value)
  next= iterador.next();
}


*/
//*******************************************************************++
















//GENERATORS






//Es convertir el codigo de una funcion en iterable

/*

function* iterable(){
  yield "hola"
  console.log("HOla consola")
  yield "Hola 2 "
  console.log("Seguimos con mas instrucciones de nuestro codigo")
  yield "hola3";
  yield "hola4";
}

let iterador = iterable()

console.log(iterador.next());
console.log(iterador.next());
console.log(iterador.next());
console.log(iterador.next());
console.log(iterador.next());


for (let y of iterador) {
  console.log(y);
}

const arr=[...iterable()]

console.log(arr)

function cuadrado(valor){
  setTimeout(() => {
  return console.log({valor,resultado:valor*valor})
  }, Math.random()*1000);

  
}

function* generador(){
  console.log("Inicia Generator")
  yield cuadrado(0)
  yield cuadrado(1)
  yield cuadrado(2)
  yield cuadrado(3)
  yield cuadrado(4)
  yield cuadrado(5)
  console.log("Termina el Generator")
}

let gen= generador()

for (let y of gen)
{
  console.log(y)
}

*/

//*******************************************************************++
















//PROXIES 

/*
const persona={
  nombre:"",
  apellido:"",
  edad:0
}

const manejador={
  set(obj,prop,valor){
    if(Object.keys(obj).indexOf(prop)=== -1){
     return console.error(`La propiedad "${prop}" no existe en el objeto persona`)
    }

   if
   ((prop=== "nombre" || prop==="apellido")&&!(/^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g.test(valor))){
    console.log(`La propiedad "${prop}" solo acepta letras y espacios en blanco`)
   }
  obj[prop]=valor
  }
}

const jon =new Proxy(persona,manejador)
jon.nombre="Jon"
jon.apellido="Fer"
jon.edad=31
jon.twitter="@jonasfenandez"
console.log(jon)


console.log(persona)

*/

//*******************************************************************++
















//PROPIEDADES DINAMICAS USUARIOS 

/*

let aleatorio= Math.round(Math.random()*100+5)

const objUsuarios={
  propiedad:"Valor",
  [`id_${aleatorio}`]:"Valor Aleatorio"
}

console.log(objUsuarios)
const usuarios=["JOn","Irma","Miguel","Kala","Kenai"];
usuarios.forEach((usuario,index)=>objUsuarios[`id_${index}`]=usuario)
console.log(objUsuarios)

*/



//*******************************************************************++
















// THIS EN JAVASCRIPT

/*
Cada funcion crea su scoope o contexto, entonces
cuando se hace referencia a this toma como referencia el scoope
de la funcion o del elemento window.
Si la variable no existe en la funcion toma como referencia
el contexto global y lo retorna COMO SE VE EN EL ULTIMO EJEMPLO DE ESTA SERIE.

Si bien el contexto es this. de la funcion la variable this.nombre no existe en 
el contexto de la funcion dentro de la funcion (referencia a funcion constructora Persona)
*/


/*
console.log(this)
console.log(window)
console.log(this === window)

this.nombre="Contexto Global"
console.log(this.nombre)

function imprimir(){
  console.log(this.nombre);
}

imprimir()


const obj={
  nombre:"Contexto objeto",
  imprimir:function(){
    console.log(this.nombre)
  }
}

obj.imprimir()

const obj2={
  nombre:"Contexto objeto2",
  imprimir
  }

obj2.imprimir()


const obj3={
  nombre:"Contexto objeto",
  imprimir:()=>{
    console.log(this.nombre)
  }
}

obj3.imprimir()


function Persona(nombre){
  this.nombre=nombre
  
  return function(){
    (console.log(this.nombre, 22))
    }
  }
let jon = new Persona("JOn")

jon()
;
*/
//*******************************************************************++
















// CALL APPLY BLIND

console.log(this)
this.lugar="Contexto Global"

function saludar(saludo,aQuien){
  console.log(`${saludo} ${aQuien} desde el ${this.lugar}`);
}


saludar("Hola","Kenai");

const obj={
  lugar:"Contexto Objeto",
}



//Toma el contexto de un objeto en vez del global
saludar.call(obj,"Hola","Jon");
saludar.call(null,"Hola","Jon")
saludar.call(this,"Hola","Jon")

//saludar.apply(obj);

//FUNCIONA IGUAL QUE EL CALL
saludar.apply(obj,["Adios","MirCha"])
saludar.apply(null,["Adios","MirCha"])
saludar.apply(this,["Adios","MirCha"])

this.nombre="Window"

const persona={
  nombre:"Jon",
  saludar:function(){
    console.log(`Hola ${this.nombre}`)
  }
}

persona.saludar()

//enlaza el contexto de otro objeto (bind) o toma el contexto global o el de una funcion 

const otraPersona ={
  saludar: persona.saludar.bind(this)
}

otraPersona.saludar()























 </script>
</body>
</html>